// api.js - Enhanced API service for TypeTutor frontend
import axios from 'axios';

// Configuration
const config = {
  baseURL: import.meta.env.VITE_API_URL || 'http://localhost:5001/api',
  timeout: 10000, // 10 second timeout
  headers: {
    'Content-Type': 'application/json',
  }
};

// Create axios instance
const apiClient = axios.create(config);

// Request interceptor for logging and auth
apiClient.interceptors.request.use(
  (config) => {
    // Log API calls in development
    if (import.meta.env.DEV) {
      console.log(`ðŸ”„ API Request: ${config.method?.toUpperCase()} ${config.url}`);
    }
    
    // Add timestamp to prevent caching issues
    if (config.method === 'get') {
      config.params = { ...config.params, _t: Date.now() };
    }
    
    return config;
  },
  (error) => {
    console.error('âŒ Request Error:', error);
    return Promise.reject(error);
  }
);

// Response interceptor for error handling and logging
apiClient.interceptors.response.use(
  (response) => {
    // Log successful responses in development
    if (import.meta.env.DEV) {
      console.log(`âœ… API Response: ${response.config.method?.toUpperCase()} ${response.config.url}`, response.data);
    }
    return response;
  },
  (error) => {
    // Enhanced error handling
    const errorInfo = {
      message: 'Unknown error occurred',
      status: error.response?.status || 500,
      statusText: error.response?.statusText || 'Internal Server Error',
      data: error.response?.data || null,
      isNetworkError: !error.response,
      timestamp: new Date().toISOString()
    };

    // Specific error messages based on status code
    if (error.code === 'ECONNREFUSED' || error.code === 'ERR_NETWORK') {
      errorInfo.message = 'Cannot connect to server. Please check if the backend is running on port 5001.';
      errorInfo.isNetworkError = true;
    } else if (error.response?.status === 404) {
      errorInfo.message = 'API endpoint not found. Please check the server configuration.';
    } else if (error.response?.status === 500) {
      errorInfo.message = 'Server error occurred. Please try again later.';
    } else if (error.response?.status === 413) {
      errorInfo.message = 'File too large. Please try a smaller file.';
    } else if (error.response?.status === 429) {
      errorInfo.message = 'Too many requests. Please wait a moment before trying again.';
    } else if (error.response?.data?.error) {
      errorInfo.message = error.response.data.error;
    } else if (error.message) {
      errorInfo.message = error.message;
    }

    console.error('âŒ API Error:', errorInfo);
    return Promise.reject(errorInfo);
  }
);

// API Health Check
export const checkHealth = async () => {
  try {
    const response = await apiClient.get('/health');
    return {
      success: true,
      data: response.data,
      timestamp: new Date().toISOString()
    };
  } catch (error) {
    return {
      success: false,
      error: error.message,
      isNetworkError: error.isNetworkError,
      timestamp: new Date().toISOString()
    };
  }
};

// PDF Support Check
export const checkPDFSupport = async () => {
  try {
    const response = await apiClient.get('/pdf-support');
    return {
      success: true,
      data: response.data
    };
  } catch (error) {
    console.warn('PDF support check failed:', error.message);
    return {
      success: false,
      error: error.message
    };
  }
};

// Upload PDF with progress tracking
export const uploadPDF = async (file, onProgress = null) => {
  if (!file) {
    throw new Error('No file provided');
  }

  if (file.type !== 'application/pdf') {
    throw new Error('Please select a PDF file');
  }

  if (file.size > 10 * 1024 * 1024) { // 10MB limit
    throw new Error('File size must be less than 10MB');
  }

  const formData = new FormData();
  formData.append('file', file);

  try {
    const response = await apiClient.post('/upload-pdf', formData, {
      headers: {
        'Content-Type': 'multipart/form-data'
      },
      onUploadProgress: (progressEvent) => {
        if (onProgress && progressEvent.total) {
          const percentCompleted = Math.round((progressEvent.loaded * 100) / progressEvent.total);
          onProgress(percentCompleted);
        }
      }
    });

    return {
      success: true,
      ...response.data
    };
  } catch (error) {
    throw {
      success: false,
      error: error.message,
      details: error.data
    };
  }
};

// Process text content
export const processText = async (text) => {
  if (!text || typeof text !== 'string') {
    throw new Error('Text content is required');
  }

  if (text.length < 10) {
    throw new Error('Text must be at least 10 characters long');
  }

  if (text.length > 50000) {
    throw new Error('Text must be less than 50,000 characters');
  }

  try {
    const response = await apiClient.post('/process-text', { 
      text: text.trim()
    });

    return {
      success: true,
      ...response.data
    };
  } catch (error) {
    throw {
      success: false,
      error: error.message,
      details: error.data
    };
  }
};

// Get user statistics
export const getStats = async (timeRange = 'all') => {
  try {
    const response = await apiClient.get('/stats', {
      params: { timeRange }
    });

    // Ensure we have default values
    const defaultStats = {
      averageWpm: 0,
      accuracy: 0,
      practiceMinutes: 0,
      currentStreak: 0,
      totalSessions: 0,
      personalBest: 0,
      lastSessionDate: null,
      recentSessions: []
    };

    return {
      ...defaultStats,
      ...response.data
    };
  } catch (error) {
    console.error('Failed to fetch stats:', error.message);
    
    // Return default stats if fetch fails
    return {
      averageWpm: 0,
      accuracy: 0,
      practiceMinutes: 0,
      currentStreak: 0,
      totalSessions: 0,
      personalBest: 0,
      lastSessionDate: null,
      recentSessions: []
    };
  }
};

// Save typing session statistics
export const saveStats = async (sessionData) => {
  if (!sessionData) {
    throw new Error('Session data is required');
  }

  // Validate required fields
  const requiredFields = ['wpm', 'accuracy', 'duration'];
  for (const field of requiredFields) {
    if (typeof sessionData[field] !== 'number') {
      throw new Error(`${field} must be a number`);
    }
  }

  // Add metadata
  const enrichedData = {
    ...sessionData,
    timestamp: new Date().toISOString(),
    userAgent: navigator.userAgent,
    sessionId: generateSessionId()
  };

  try {
    const response = await apiClient.post('/save-stats', enrichedData);
    return {
      success: true,
      ...response.data
    };
  } catch (error) {
    throw {
      success: false,
      error: error.message,
      details: error.data
    };
  }
};

// Reset user statistics (admin function)
export const resetStats = async () => {
  try {
    const response = await apiClient.post('/reset-stats');
    return {
      success: true,
      message: 'Statistics reset successfully',
      ...response.data
    };
  } catch (error) {
    throw {
      success: false,
      error: error.message,
      details: error.data
    };
  }
};

// Get debug information
export const getDebugInfo = async () => {
  try {
    const response = await apiClient.get('/debug-info');
    return {
      success: true,
      data: response.data
    };
  } catch (error) {
    return {
      success: false,
      error: error.message,
      isNetworkError: error.isNetworkError
    };
  }
};

// Get debug statistics
export const getDebugStats = async () => {
  try {
    const response = await apiClient.get('/debug-stats');
    return {
      success: true,
      data: response.data
    };
  } catch (error) {
    return {
      success: false,
      error: error.message
    };
  }
};

// Utility function to generate session ID
const generateSessionId = () => {
  return Date.now().toString(36) + Math.random().toString(36).substr(2);
};

// Utility function to test API connectivity
export const testConnection = async () => {
  const results = {
    health: { status: 'pending' },
    pdfSupport: { status: 'pending' },
    stats: { status: 'pending' }
  };

  // Test health endpoint
  try {
    await checkHealth();
    results.health = { status: 'success', message: 'Health check passed' };
  } catch (error) {
    results.health = { status: 'error', message: error.message };
  }

  // Test PDF support
  try {
    await checkPDFSupport();
    results.pdfSupport = { status: 'success', message: 'PDF support available' };
  } catch (error) {
    results.pdfSupport = { status: 'error', message: error.message };
  }

  // Test stats endpoint
  try {
    await getStats();
    results.stats = { status: 'success', message: 'Stats endpoint working' };
  } catch (error) {
    results.stats = { status: 'error', message: error.message };
  }

  return results;
};

// Export API client for advanced usage
export { apiClient };

// Export configuration for debugging
export const getApiConfig = () => ({
  baseURL: config.baseURL,
  timeout: config.timeout,
  isDevelopment: import.meta.env.DEV,
  environment: import.meta.env.MODE
});